From 9c2138c4671f31f61c500aa12b40915b60627144 Mon Sep 17 00:00:00 2001
From: hai <mima0000@DMMAC.local>
Date: Thu, 12 Feb 2026 04:22:08 +0800
Subject: [PATCH 1/5] feat(core): auto-reconnect MCP servers on disconnect

---
 codex-rs/core/src/mcp_connection_manager.rs   | 315 +++++++++++++++---
 codex-rs/core/tests/suite/rmcp_client.rs      | 211 ++++++++++++
 .../rmcp-client/src/bin/test_stdio_server.rs  |  46 ++-
 3 files changed, 528 insertions(+), 44 deletions(-)

diff --git a/codex-rs/core/src/mcp_connection_manager.rs b/codex-rs/core/src/mcp_connection_manager.rs
index 6f6bfad6e..584417b15 100644
--- a/codex-rs/core/src/mcp_connection_manager.rs
+++ b/codex-rs/core/src/mcp_connection_manager.rs
@@ -264,11 +264,27 @@ impl ManagedClient {
 
 #[derive(Clone)]
 struct AsyncManagedClient {
-    client: Shared<BoxFuture<'static, Result<ManagedClient, StartupOutcomeError>>>,
+    builder: ManagedClientBuilder,
+    client: Arc<Mutex<ManagedClientFuture>>,
 }
 
-impl AsyncManagedClient {
-    fn new(
+type ManagedClientFuture = Shared<BoxFuture<'static, Result<ManagedClient, StartupOutcomeError>>>;
+
+#[derive(Clone)]
+struct ManagedClientBuilder {
+    server_name: String,
+    transport: McpServerTransportConfig,
+    store_mode: OAuthCredentialsStoreMode,
+    startup_timeout: Option<Duration>,
+    tool_timeout: Duration,
+    tool_filter: ToolFilter,
+    cancel_token: CancellationToken,
+    tx_event: Sender<Event>,
+    elicitation_requests: ElicitationRequestManager,
+}
+
+impl ManagedClientBuilder {
+    fn from_config(
         server_name: String,
         config: McpServerConfig,
         store_mode: OAuthCredentialsStoreMode,
@@ -277,18 +293,40 @@ impl AsyncManagedClient {
         elicitation_requests: ElicitationRequestManager,
     ) -> Self {
         let tool_filter = ToolFilter::from_config(&config);
-        let fut = async move {
+        Self {
+            server_name,
+            transport: config.transport,
+            store_mode,
+            startup_timeout: config.startup_timeout_sec.or(Some(DEFAULT_STARTUP_TIMEOUT)),
+            tool_timeout: config.tool_timeout_sec.unwrap_or(DEFAULT_TOOL_TIMEOUT),
+            tool_filter,
+            cancel_token,
+            tx_event,
+            elicitation_requests,
+        }
+    }
+
+    fn connect(&self) -> ManagedClientFuture {
+        let server_name = self.server_name.clone();
+        let transport = self.transport.clone();
+        let store_mode = self.store_mode;
+        let startup_timeout = self.startup_timeout;
+        let tool_timeout = self.tool_timeout;
+        let tool_filter = self.tool_filter.clone();
+        let cancel_token = self.cancel_token.clone();
+        let tx_event = self.tx_event.clone();
+        let elicitation_requests = self.elicitation_requests.clone();
+        async move {
             if let Err(error) = validate_mcp_server_name(&server_name) {
                 return Err(error.into());
             }
 
-            let client =
-                Arc::new(make_rmcp_client(&server_name, config.transport, store_mode).await?);
+            let client = Arc::new(make_rmcp_client(&server_name, transport, store_mode).await?);
             match start_server_task(
                 server_name,
                 client,
-                config.startup_timeout_sec.or(Some(DEFAULT_STARTUP_TIMEOUT)),
-                config.tool_timeout_sec.unwrap_or(DEFAULT_TOOL_TIMEOUT),
+                startup_timeout,
+                tool_timeout,
                 tool_filter,
                 tx_event,
                 elicitation_requests,
@@ -299,18 +337,62 @@ impl AsyncManagedClient {
                 Ok(result) => result,
                 Err(CancelErr::Cancelled) => Err(StartupOutcomeError::Cancelled),
             }
-        };
+        }
+        .boxed()
+        .shared()
+    }
+}
+
+impl AsyncManagedClient {
+    fn new(
+        server_name: String,
+        config: McpServerConfig,
+        store_mode: OAuthCredentialsStoreMode,
+        cancel_token: CancellationToken,
+        tx_event: Sender<Event>,
+        elicitation_requests: ElicitationRequestManager,
+    ) -> Self {
+        let builder = ManagedClientBuilder::from_config(
+            server_name,
+            config,
+            store_mode,
+            cancel_token,
+            tx_event,
+            elicitation_requests,
+        );
         Self {
-            client: fut.boxed().shared(),
+            client: Arc::new(Mutex::new(builder.connect())),
+            builder,
         }
     }
 
+    async fn client_future(&self) -> ManagedClientFuture {
+        self.client.lock().await.clone()
+    }
+
     async fn client(&self) -> Result<ManagedClient, StartupOutcomeError> {
-        self.client.clone().await
+        self.client_future().await.await
+    }
+
+    async fn reconnect(&self) -> Result<ManagedClient, StartupOutcomeError> {
+        let future = self.builder.connect();
+        {
+            let mut guard = self.client.lock().await;
+            *guard = future.clone();
+        }
+        future.await
+    }
+
+    async fn client_or_reconnect(&self) -> Result<ManagedClient, StartupOutcomeError> {
+        match self.client().await {
+            Ok(client) => Ok(client),
+            Err(StartupOutcomeError::Cancelled) => Err(StartupOutcomeError::Cancelled),
+            Err(StartupOutcomeError::Failed { .. }) => self.reconnect().await,
+        }
     }
 
     async fn notify_sandbox_state_change(&self, sandbox_state: &SandboxState) -> Result<()> {
-        let managed = self.client().await?;
+        let managed = self.client_or_reconnect().await?;
         managed.notify_sandbox_state_change(sandbox_state).await
     }
 }
@@ -336,6 +418,7 @@ pub struct SandboxState {
 pub(crate) struct McpConnectionManager {
     clients: HashMap<String, AsyncManagedClient>,
     elicitation_requests: ElicitationRequestManager,
+    sandbox_state: Arc<Mutex<Option<SandboxState>>>,
 }
 
 impl McpConnectionManager {
@@ -351,6 +434,10 @@ impl McpConnectionManager {
         if cancel_token.is_cancelled() {
             return;
         }
+        {
+            let mut sandbox_state_guard = self.sandbox_state.lock().await;
+            *sandbox_state_guard = Some(initial_sandbox_state.clone());
+        }
         let mut clients = HashMap::new();
         let mut join_set = JoinSet::new();
         let elicitation_requests = ElicitationRequestManager::default();
@@ -443,13 +530,37 @@ impl McpConnectionManager {
         });
     }
 
-    async fn client_by_name(&self, name: &str) -> Result<ManagedClient> {
+    fn async_client_by_name(&self, name: &str) -> Result<&AsyncManagedClient> {
         self.clients
             .get(name)
-            .ok_or_else(|| anyhow!("unknown MCP server '{name}'"))?
-            .client()
+            .ok_or_else(|| anyhow!("unknown MCP server '{name}'"))
+    }
+
+    async fn reconnect_client(&self, server_name: &str) -> Result<ManagedClient> {
+        let async_client = self.async_client_by_name(server_name)?;
+        let managed = async_client
+            .reconnect()
             .await
-            .context("failed to get client")
+            .with_context(|| format!("failed to reconnect MCP server `{server_name}`"))?;
+
+        if let Some(sandbox_state) = self.sandbox_state.lock().await.clone()
+            && let Err(error) = managed.notify_sandbox_state_change(&sandbox_state).await
+        {
+            warn!(
+                "Failed to notify sandbox state to reconnected MCP server {server_name}: {error:#}",
+            );
+        }
+
+        Ok(managed)
+    }
+
+    async fn client_by_name(&self, name: &str) -> Result<ManagedClient> {
+        let async_client = self.async_client_by_name(name)?;
+        match async_client.client().await {
+            Ok(client) => Ok(client),
+            Err(StartupOutcomeError::Cancelled) => Err(anyhow!("MCP startup cancelled")),
+            Err(StartupOutcomeError::Failed { .. }) => self.reconnect_client(name).await,
+        }
     }
 
     pub async fn resolve_elicitation(
@@ -505,7 +616,7 @@ impl McpConnectionManager {
     pub async fn list_all_tools(&self) -> HashMap<String, ToolInfo> {
         let mut tools = HashMap::new();
         for (server_name, managed_client) in &self.clients {
-            let client = managed_client.client().await.ok();
+            let client = managed_client.client_or_reconnect().await.ok();
             if let Some(client) = client {
                 let rmcp_client = client.client;
                 let tool_timeout = client.tool_timeout;
@@ -567,7 +678,7 @@ impl McpConnectionManager {
 
         for (server_name, async_managed_client) in clients_snapshot {
             let server_name = server_name.clone();
-            let Ok(managed_client) = async_managed_client.client().await else {
+            let Ok(managed_client) = async_managed_client.client_or_reconnect().await else {
                 continue;
             };
             let timeout = managed_client.tool_timeout;
@@ -633,7 +744,7 @@ impl McpConnectionManager {
 
         for (server_name, async_managed_client) in clients_snapshot {
             let server_name_cloned = server_name.clone();
-            let Ok(managed_client) = async_managed_client.client().await else {
+            let Ok(managed_client) = async_managed_client.client_or_reconnect().await else {
                 continue;
             };
             let client = managed_client.client.clone();
@@ -701,18 +812,31 @@ impl McpConnectionManager {
         tool: &str,
         arguments: Option<serde_json::Value>,
     ) -> Result<CallToolResult> {
-        let client = self.client_by_name(server).await?;
-        if !client.tool_filter.allows(tool) {
-            return Err(anyhow!(
-                "tool '{tool}' is disabled for MCP server '{server}'"
-            ));
-        }
+        let managed_client = self.client_by_name(server).await?;
+        let tool_name = tool.to_string();
+
+        let call_result = match call_tool_with_managed_client(
+            &managed_client,
+            server,
+            &tool_name,
+            arguments.clone(),
+        )
+        .await
+        {
+            Ok(result) => Ok(result),
+            Err(error) if is_connection_error(&error) => {
+                warn!(
+                    "MCP tool call for `{server}/{tool}` failed due to connection error; reconnecting and retrying: {error:#}",
+                );
+                let reconnected_client = self.reconnect_client(server).await?;
+                call_tool_with_managed_client(&reconnected_client, server, &tool_name, arguments)
+                    .await
+            }
+            Err(error) => Err(error),
+        };
 
-        let result: rmcp::model::CallToolResult = client
-            .client
-            .call_tool(tool.to_string(), arguments, client.tool_timeout)
-            .await
-            .with_context(|| format!("tool call failed for `{server}/{tool}`"))?;
+        let result: rmcp::model::CallToolResult =
+            call_result.with_context(|| format!("tool call failed for `{server}/{tool}`"))?;
 
         let content = result
             .content
@@ -740,11 +864,22 @@ impl McpConnectionManager {
         let managed = self.client_by_name(server).await?;
         let timeout = managed.tool_timeout;
 
-        managed
-            .client
-            .list_resources(params, timeout)
-            .await
-            .with_context(|| format!("resources/list failed for `{server}`"))
+        let list_result = match managed.client.list_resources(params.clone(), timeout).await {
+            Ok(result) => Ok(result),
+            Err(error) if is_connection_error(&error) => {
+                warn!(
+                    "MCP resources/list for `{server}` failed due to connection error; reconnecting and retrying: {error:#}",
+                );
+                let reconnected_client = self.reconnect_client(server).await?;
+                reconnected_client
+                    .client
+                    .list_resources(params, reconnected_client.tool_timeout)
+                    .await
+            }
+            Err(error) => Err(error),
+        };
+
+        list_result.with_context(|| format!("resources/list failed for `{server}`"))
     }
 
     /// List resource templates from the specified server.
@@ -757,10 +892,25 @@ impl McpConnectionManager {
         let client = managed.client.clone();
         let timeout = managed.tool_timeout;
 
-        client
-            .list_resource_templates(params, timeout)
+        let list_result = match client
+            .list_resource_templates(params.clone(), timeout)
             .await
-            .with_context(|| format!("resources/templates/list failed for `{server}`"))
+        {
+            Ok(result) => Ok(result),
+            Err(error) if is_connection_error(&error) => {
+                warn!(
+                    "MCP resources/templates/list for `{server}` failed due to connection error; reconnecting and retrying: {error:#}",
+                );
+                let reconnected_client = self.reconnect_client(server).await?;
+                reconnected_client
+                    .client
+                    .list_resource_templates(params, reconnected_client.tool_timeout)
+                    .await
+            }
+            Err(error) => Err(error),
+        };
+
+        list_result.with_context(|| format!("resources/templates/list failed for `{server}`"))
     }
 
     /// Read a resource from the specified server.
@@ -770,14 +920,28 @@ impl McpConnectionManager {
         params: ReadResourceRequestParams,
     ) -> Result<ReadResourceResult> {
         let managed = self.client_by_name(server).await?;
-        let client = managed.client.clone();
-        let timeout = managed.tool_timeout;
         let uri = params.uri.clone();
 
-        client
-            .read_resource(params, timeout)
+        let read_result = match managed
+            .client
+            .read_resource(params.clone(), managed.tool_timeout)
             .await
-            .with_context(|| format!("resources/read failed for `{server}` ({uri})"))
+        {
+            Ok(result) => Ok(result),
+            Err(error) if is_connection_error(&error) => {
+                warn!(
+                    "MCP resources/read for `{server}` failed due to connection error; reconnecting and retrying: {error:#}",
+                );
+                let reconnected_client = self.reconnect_client(server).await?;
+                reconnected_client
+                    .client
+                    .read_resource(params, reconnected_client.tool_timeout)
+                    .await
+            }
+            Err(error) => Err(error),
+        };
+
+        read_result.with_context(|| format!("resources/read failed for `{server}` ({uri})"))
     }
 
     pub async fn parse_tool_name(&self, tool_name: &str) -> Option<(String, String)> {
@@ -788,6 +952,11 @@ impl McpConnectionManager {
     }
 
     pub async fn notify_sandbox_state_change(&self, sandbox_state: &SandboxState) -> Result<()> {
+        {
+            let mut sandbox_state_guard = self.sandbox_state.lock().await;
+            *sandbox_state_guard = Some(sandbox_state.clone());
+        }
+
         let mut join_set = JoinSet::new();
 
         for async_managed_client in self.clients.values() {
@@ -816,6 +985,49 @@ impl McpConnectionManager {
     }
 }
 
+async fn call_tool_with_managed_client(
+    managed_client: &ManagedClient,
+    server: &str,
+    tool: &str,
+    arguments: Option<serde_json::Value>,
+) -> Result<rmcp::model::CallToolResult> {
+    if !managed_client.tool_filter.allows(tool) {
+        return Err(anyhow!(
+            "tool '{tool}' is disabled for MCP server '{server}'"
+        ));
+    }
+
+    managed_client
+        .client
+        .call_tool(tool.to_string(), arguments, managed_client.tool_timeout)
+        .await
+}
+
+fn is_connection_error(error: &anyhow::Error) -> bool {
+    const CONNECTION_ERROR_HINTS: [&str; 9] = [
+        "broken pipe",
+        "connection reset",
+        "connection closed",
+        "connection aborted",
+        "unexpected eof",
+        "transport closed",
+        "channel closed",
+        "client not initialized",
+        "not connected",
+    ];
+
+    error.chain().any(|cause| {
+        if cause.downcast_ref::<std::io::Error>().is_some() {
+            return true;
+        }
+
+        let message = cause.to_string().to_ascii_lowercase();
+        CONNECTION_ERROR_HINTS
+            .iter()
+            .any(|hint| message.contains(hint))
+    })
+}
+
 async fn emit_update(
     tx_event: &Sender<Event>,
     update: McpStartupUpdateEvent,
@@ -1497,4 +1709,21 @@ mod tests {
             display
         );
     }
+
+    #[test]
+    fn is_connection_error_detects_io_errors() {
+        let error = anyhow::Error::new(std::io::Error::new(
+            std::io::ErrorKind::BrokenPipe,
+            "pipe closed",
+        ));
+
+        assert!(is_connection_error(&error));
+    }
+
+    #[test]
+    fn is_connection_error_ignores_application_errors() {
+        let error = anyhow::anyhow!("unknown tool: echo");
+
+        assert!(!is_connection_error(&error));
+    }
 }
diff --git a/codex-rs/core/tests/suite/rmcp_client.rs b/codex-rs/core/tests/suite/rmcp_client.rs
index a1bf72b10..98f3145b9 100644
--- a/codex-rs/core/tests/suite/rmcp_client.rs
+++ b/codex-rs/core/tests/suite/rmcp_client.rs
@@ -189,6 +189,217 @@ async fn stdio_server_round_trip() -> anyhow::Result<()> {
     Ok(())
 }
 
+#[tokio::test(flavor = "multi_thread", worker_threads = 1)]
+#[serial(mcp_test_value)]
+async fn stdio_server_reconnects_after_disconnect() -> anyhow::Result<()> {
+    skip_if_no_network!(Ok(()));
+
+    let server = responses::start_mock_server().await;
+
+    let server_name = "rmcp_reconnect";
+    let tool_name = format!("mcp__{server_name}__echo");
+    let call_ids = ["call-reconnect-1", "call-reconnect-2"];
+
+    mount_sse_once(
+        &server,
+        responses::sse(vec![
+            responses::ev_response_created("resp-reconnect-1"),
+            responses::ev_function_call(call_ids[0], &tool_name, "{\"message\":\"ping-1\"}"),
+            responses::ev_completed("resp-reconnect-1"),
+        ]),
+    )
+    .await;
+    mount_sse_once(
+        &server,
+        responses::sse(vec![
+            responses::ev_assistant_message("msg-reconnect-1", "first rmcp call completed."),
+            responses::ev_completed("resp-reconnect-2"),
+        ]),
+    )
+    .await;
+    mount_sse_once(
+        &server,
+        responses::sse(vec![
+            responses::ev_response_created("resp-reconnect-3"),
+            responses::ev_function_call(call_ids[1], &tool_name, "{\"message\":\"ping-2\"}"),
+            responses::ev_completed("resp-reconnect-3"),
+        ]),
+    )
+    .await;
+    mount_sse_once(
+        &server,
+        responses::sse(vec![
+            responses::ev_assistant_message("msg-reconnect-2", "second rmcp call completed."),
+            responses::ev_completed("resp-reconnect-4"),
+        ]),
+    )
+    .await;
+
+    let expected_env_value = "propagated-env-reconnect";
+    let rmcp_test_server_bin = stdio_server_bin()?;
+
+    let fixture = test_codex()
+        .with_config(move |config| {
+            let mut servers = config.mcp_servers.get().clone();
+            servers.insert(
+                server_name.to_string(),
+                McpServerConfig {
+                    transport: McpServerTransportConfig::Stdio {
+                        command: rmcp_test_server_bin,
+                        args: Vec::new(),
+                        env: Some(HashMap::from([
+                            ("MCP_TEST_VALUE".to_string(), expected_env_value.to_string()),
+                            ("MCP_EXIT_AFTER_CALLS".to_string(), "1".to_string()),
+                        ])),
+                        env_vars: Vec::new(),
+                        cwd: None,
+                    },
+                    enabled: true,
+                    disabled_reason: None,
+                    startup_timeout_sec: Some(Duration::from_secs(10)),
+                    tool_timeout_sec: None,
+                    enabled_tools: None,
+                    disabled_tools: None,
+                    scopes: None,
+                },
+            );
+            config
+                .mcp_servers
+                .set(servers)
+                .expect("test mcp servers should accept any configuration");
+        })
+        .build(&server)
+        .await?;
+    let session_model = fixture.session_configured.model.clone();
+
+    fixture
+        .codex
+        .submit(Op::UserTurn {
+            items: vec![UserInput::Text {
+                text: "call the reconnect test rmcp tool".into(),
+                text_elements: Vec::new(),
+            }],
+            final_output_json_schema: None,
+            cwd: fixture.cwd.path().to_path_buf(),
+            approval_policy: AskForApproval::Never,
+            sandbox_policy: SandboxPolicy::ReadOnly,
+            model: session_model.clone(),
+            effort: None,
+            summary: ReasoningSummary::Auto,
+            collaboration_mode: None,
+            personality: None,
+        })
+        .await?;
+
+    let begin_event = wait_for_event(&fixture.codex, |ev| {
+        matches!(ev, EventMsg::McpToolCallBegin(_))
+    })
+    .await;
+    let EventMsg::McpToolCallBegin(begin) = begin_event else {
+        unreachable!("event guard guarantees McpToolCallBegin");
+    };
+    assert_eq!(begin.invocation.server, server_name);
+    assert_eq!(begin.invocation.tool, "echo");
+
+    let end_event = wait_for_event(&fixture.codex, |ev| {
+        matches!(ev, EventMsg::McpToolCallEnd(_))
+    })
+    .await;
+    let EventMsg::McpToolCallEnd(end) = end_event else {
+        unreachable!("event guard guarantees McpToolCallEnd");
+    };
+    let result = end
+        .result
+        .as_ref()
+        .expect("first rmcp echo tool call should succeed");
+    assert_eq!(result.is_error, Some(false));
+    let structured = result
+        .structured_content
+        .as_ref()
+        .expect("structured content");
+    let Value::Object(first_map) = structured else {
+        panic!("structured content should be an object: {structured:?}");
+    };
+    let first_echo = first_map
+        .get("echo")
+        .and_then(Value::as_str)
+        .expect("echo payload present");
+    assert_eq!(first_echo, "ECHOING: ping-1");
+    let first_env = first_map
+        .get("env")
+        .and_then(Value::as_str)
+        .expect("env snapshot inserted");
+    assert_eq!(first_env, expected_env_value);
+
+    wait_for_event(&fixture.codex, |ev| matches!(ev, EventMsg::TurnComplete(_))).await;
+    sleep(Duration::from_millis(100)).await;
+
+    fixture
+        .codex
+        .submit(Op::UserTurn {
+            items: vec![UserInput::Text {
+                text: "call the reconnect test rmcp tool again".into(),
+                text_elements: Vec::new(),
+            }],
+            final_output_json_schema: None,
+            cwd: fixture.cwd.path().to_path_buf(),
+            approval_policy: AskForApproval::Never,
+            sandbox_policy: SandboxPolicy::ReadOnly,
+            model: session_model,
+            effort: None,
+            summary: ReasoningSummary::Auto,
+            collaboration_mode: None,
+            personality: None,
+        })
+        .await?;
+
+    let begin_event = wait_for_event(&fixture.codex, |ev| {
+        matches!(ev, EventMsg::McpToolCallBegin(_))
+    })
+    .await;
+    let EventMsg::McpToolCallBegin(begin) = begin_event else {
+        unreachable!("event guard guarantees McpToolCallBegin");
+    };
+    assert_eq!(begin.invocation.server, server_name);
+    assert_eq!(begin.invocation.tool, "echo");
+
+    let end_event = wait_for_event(&fixture.codex, |ev| {
+        matches!(ev, EventMsg::McpToolCallEnd(_))
+    })
+    .await;
+    let EventMsg::McpToolCallEnd(end) = end_event else {
+        unreachable!("event guard guarantees McpToolCallEnd");
+    };
+    let result = end
+        .result
+        .as_ref()
+        .expect("second rmcp echo tool call should succeed after reconnect");
+    assert_eq!(result.is_error, Some(false));
+    let structured = result
+        .structured_content
+        .as_ref()
+        .expect("structured content");
+    let Value::Object(second_map) = structured else {
+        panic!("structured content should be an object: {structured:?}");
+    };
+    let second_echo = second_map
+        .get("echo")
+        .and_then(Value::as_str)
+        .expect("echo payload present");
+    assert_eq!(second_echo, "ECHOING: ping-2");
+    let second_env = second_map
+        .get("env")
+        .and_then(Value::as_str)
+        .expect("env snapshot inserted");
+    assert_eq!(second_env, expected_env_value);
+
+    wait_for_event(&fixture.codex, |ev| matches!(ev, EventMsg::TurnComplete(_))).await;
+
+    server.verify().await;
+
+    Ok(())
+}
+
 #[tokio::test(flavor = "multi_thread", worker_threads = 1)]
 #[serial(mcp_test_value)]
 async fn stdio_image_responses_round_trip() -> anyhow::Result<()> {
diff --git a/codex-rs/rmcp-client/src/bin/test_stdio_server.rs b/codex-rs/rmcp-client/src/bin/test_stdio_server.rs
index d7708bf5e..da2eb3670 100644
--- a/codex-rs/rmcp-client/src/bin/test_stdio_server.rs
+++ b/codex-rs/rmcp-client/src/bin/test_stdio_server.rs
@@ -1,6 +1,7 @@
 use std::borrow::Cow;
 use std::collections::HashMap;
 use std::sync::Arc;
+use std::time::Duration;
 
 use rmcp::ErrorData as McpError;
 use rmcp::ServiceExt;
@@ -31,6 +32,7 @@ struct TestToolServer {
     tools: Arc<Vec<Tool>>,
     resources: Arc<Vec<Resource>>,
     resource_templates: Arc<Vec<ResourceTemplate>>,
+    exit_after_calls: Option<Arc<tokio::sync::Mutex<usize>>>,
 }
 
 const MEMO_URI: &str = "memo://codex/example-note";
@@ -50,10 +52,23 @@ impl TestToolServer {
         ];
         let resources = vec![Self::memo_resource()];
         let resource_templates = vec![Self::memo_template()];
+        let exit_after_calls = std::env::var("MCP_EXIT_AFTER_CALLS")
+            .ok()
+            .and_then(|value| {
+                value
+                    .parse::<usize>()
+                    .inspect_err(|error| {
+                        eprintln!("invalid MCP_EXIT_AFTER_CALLS value `{value}`: {error}");
+                    })
+                    .ok()
+            })
+            .filter(|value| *value > 0)
+            .map(|value| Arc::new(tokio::sync::Mutex::new(value)));
         Self {
             tools: Arc::new(tools),
             resources: Arc::new(resources),
             resource_templates: Arc::new(resource_templates),
+            exit_after_calls,
         }
     }
 
@@ -295,7 +310,7 @@ impl ServerHandler for TestToolServer {
         request: CallToolRequestParams,
         _context: rmcp::service::RequestContext<rmcp::service::RoleServer>,
     ) -> Result<CallToolResult, McpError> {
-        match request.name.as_ref() {
+        let result = match request.name.as_ref() {
             "echo" => {
                 let args: EchoArgs = match request.arguments {
                     Some(arguments) => serde_json::from_value(serde_json::Value::Object(
@@ -352,7 +367,13 @@ impl ServerHandler for TestToolServer {
                 format!("unknown tool: {other}"),
                 None,
             )),
+        };
+
+        if result.is_ok() {
+            self.schedule_exit_after_call_if_needed().await;
         }
+
+        result
     }
 }
 
@@ -430,6 +451,29 @@ impl TestToolServer {
 
         Ok(CallToolResult::success(content))
     }
+
+    async fn schedule_exit_after_call_if_needed(&self) {
+        let Some(remaining_calls) = &self.exit_after_calls else {
+            return;
+        };
+
+        let should_exit = {
+            let mut remaining = remaining_calls.lock().await;
+            if *remaining == 0 {
+                false
+            } else {
+                *remaining -= 1;
+                *remaining == 0
+            }
+        };
+
+        if should_exit {
+            tokio::spawn(async move {
+                tokio::time::sleep(Duration::from_millis(25)).await;
+                std::process::exit(0);
+            });
+        }
+    }
 }
 
 fn parse_data_url(url: &str) -> Option<(String, String)> {
-- 
2.39.2 (Apple Git-143)

